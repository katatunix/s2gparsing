package com.nghiabui.s2gparsing;

import com.nghiabui.kommon.AppException;
import com.nghiabui.kommon.ListOperation;
import com.nghiabui.kommon.Tuple;
import com.nghiabui.s2gparsing.macro.ResolvedMacros;
import com.nghiabui.s2gparsing.macro.TextSplitter;
import com.nghiabui.kommon.xml.NodeUtil;
import org.w3c.dom.Element;

import java.util.*;
import java.util.stream.Collectors;

class NonmacConfig {
	
	private final List<Element> elements;
	private final ResolvedMacros macros;
	
	public NonmacConfig(List<Element> elements, ResolvedMacros macros) {
		this.elements = elements;
		this.macros = macros;
	}
	
	public String msvcConfiguration(boolean release) {
		final Optional<Element> op = rootElements("MSVCConfiguration").stream().findFirst();
		String name = !op.isPresent() ? "Release" : op.get().getAttribute(release ? "Release" : "Debug");
		if (!name.contains("|")) {
			name += "|Win32";
		}
		return name;
	}
	
	private List<Element> rootElements(String tag) {
		return elements.stream().filter(e -> e.getTagName().equals(tag)).collect(Collectors.toList());
	}
	
	public List<String> additionalPatterns(boolean release) {
		return extractNames("AddSourceFileToProject", "File", release);
	}
	
	public List<String> ignoredPatterns(boolean release) {
		return extractNames("Ignore", "File", release);
	}
	
	public List<String> ignoredFilters(boolean release) {
		return extractNames("Ignore", "Filter", release);
	}
	
	private List<String> extractNames(String rootTag, String subTag, boolean release) {
		return extractNames(rootElements(rootTag), subTag, release);
	}
	
	private List<String> extractNames(List<Element> mainElements, String subTag, boolean release) {
		return mainElements.stream()
			.flatMap(e -> NodeUtil.toList(e.getChildNodes()).stream()
				.filter(file -> file.getTagName().equals(subTag))
				.map(file -> file.getAttribute("Name"))
				.map(name -> macros.resolveValue(name, release))
				.filter(name -> !name.isEmpty())
			)
			.collect(Collectors.toList());
	}
	
	public int ubNumber() {
		final Optional<Element> opAutoGenerated = autoGeneratedElement();
		if (!opAutoGenerated.isPresent()) return 0;
		final String number = opAutoGenerated.get().getAttribute("UnityBuildsNumber");
		if (number.isEmpty()) return 0;
		try {
			return Integer.valueOf(number);
		} catch (Exception ex) {
			throw new AppException(ex);
		}
	}
	
	private Optional<Element> autoGeneratedElement() {
		final List<Element> unityBuildsList = rootElements("UnityBuilds");
		return unityBuildsList.isEmpty() ?
			Optional.empty() :
			NodeUtil.toList(unityBuildsList.get(0).getChildNodes()).stream()
				.filter(e -> e.getTagName().equals("AutoGenerated"))
				.findFirst();
	}
	
	public List<String> ubExcludedPatterns(boolean release) {
		return extractNames(
			ListOperation.op2list(autoGeneratedElement()), "ExcludeFileFromUnityBuild", release
		);
	}
	
	public List<Tuple<String, Set<String>>> specFlags(boolean release) {
		return rootElements("FileSpecific").stream()
			.flatMap(fsElement ->
				NodeUtil.toList(fsElement.getChildNodes()).stream()
					.filter(file ->
						file.getTagName().equals("File") &&
							!file.getAttribute("Name").isEmpty() &&
							!file.getAttribute("CFLAGS").isEmpty()
					)
					.map(file -> new Tuple<>(
						macros.resolveValue(file.getAttribute("Name"), release),
						FlagCorrector.correct(TextSplitter.split(file.getAttribute("CFLAGS")))
					))
			)
			.collect(Collectors.toList());
	}
	
}
